| 파일명 | 분류 | 설명 |
| :--- | :--- | :--- |
| `defaultdict_counter.py` | **자료구조** | 일반 딕셔너리로 요소의 개수를 세려면 키가 존재하는지 항상 확인해야 하지만, `collections.defaultdict`를 사용하면 이 과정을 생략할 수 있습니다. 존재하지 않는 키를 조회할 때 `int()`의 기본값인 0을 자동으로 생성해주므로, 키 존재 여부를 검사하는 `if`문 없이 코드를 훨씬 간결하고 효율적으로 작성하는 방법을 보여줍니다. |
| `dictionary_iteration.py` | **자료구조** | 딕셔너리의 데이터를 순회하는 세 가지 주요 방법을 설명합니다. 단순히 `for key in dict:` 구문을 사용하여 키만 순회하는 방법, `.values()` 메소드로 값만 순회하는 방법, 그리고 `.items()` 메소드를 사용하여 (키, 값) 튜플을 얻어와 두 가지 모두를 동시에 활용하는 가장 일반적인 순회 방법을 비교하여 보여줍니다. |
| `hashable_keys.py` | **빈출오류** | 딕셔너리의 키는 반드시 '해시 가능(hashable)'해야 한다는 개념을 설명합니다. '해시 가능'이란 객체의 내용이 변하지 않아 고유한 해시값을 유지할 수 있음을 의미합니다. 따라서 내용 변경이 가능한(mutable) 리스트는 키가 될 수 없어 `TypeError`가 발생하고, 내용 변경이 불가능한(immutable) 튜플은 키로 사용될 수 있음을 코드로 증명합니다. |
| `list_comprehensions.py` | **알고리즘** | 파이썬의 강력하고 간결한 문법인 리스트 컴프리헨션의 활용법을 보여줍니다. 기존의 `for` 루프와 `if` 조건문을 사용하여 리스트를 생성하는 방식과, 이를 단 한 줄의 코드로 압축하여 가독성과 효율성을 높이는 리스트 컴프리헨션 방식을 비교하여 설명합니다. |
| `list_slicing.py` | **자료구조** | 리스트의 특정 부분을 잘라내어 새로운 리스트를 만드는 슬라이싱(`[start:stop:step]`) 문법을 상세히 다룹니다. 단순히 일부를 잘라내는 것 외에도, `step` 값을 이용하여 짝수/홀수 인덱스만 추출하거나, `step`을 음수로 설정하여 리스트 전체를 간단하게 뒤집는 등 실용적인 활용 예제를 보여줍니다. |
| `pop_performance.py` | **성능비교** | 리스트의 맨 앞 요소를 제거하는 연산의 성능 차이를 비교합니다. 일반 리스트의 `pop(0)`는 O(n)의 시간 복잡도를 가집니다. 맨 앞 요소가 제거되면 나머지 모든 요소들을 한 칸씩 앞으로 당겨야 하기 때문입니다. 반면, `collections.deque`의 `popleft()`는 내부적으로 이중 연결 리스트로 구현되어 있어 O(1)의 빠른 성능을 보이는 이유를 설명합니다. |
| `search_comparison.py` | **성능비교** | `list`와 `set`에서 특정 요소의 존재 여부를 확인하는 `in` 연산자의 성능을 비교합니다. 리스트는 처음부터 끝까지 모든 요소를 확인하는 선형 탐색(O(n))을 수행합니다. 반면, `set`은 해시 테이블 구조를 사용하여 데이터의 양과 관계없이 거의 일정한 시간(O(1)) 안에 요소의 위치를 바로 계산할 수 있어 훨씬 빠른 검색 속도를 보여줍니다. |
| `set_operations.py` | **자료구조** | 파이썬의 `set` 자료구조가 제공하는 강력한 집합 연산 기능을 설명합니다. 두 집합의 모든 요소를 포함하는 합집합,공통된 요소만 추출하는 교집합, 특정 집합에만 존재하는 요소를 찾는 차집합의 사용법을 연산자와 메소드 두 가지 방식으로 보여줍니다. |
| `string_concatenation.py` | **성능비교** | 여러 개의 문자열을 합치는 두 가지 방법의 성능 차이를 보여줍니다. 파이썬의 문자열은 불변(immutable) 객체이므로 `+` 연산을 반복하면 매번 새로운 문자열 객체가 생성되고 복사되어 O(n^2)의 비효율을 보입니다. 반면, `.join()` 메소드는 필요한 메모리를 한 번에 할당한 후 모든 문자열을 복사하므로 O(n)의 훨씬 뛰어난 성능을 보이는 이유를 설명합니다. |
| `tuple_unpacking.py` | **자료구조** | 튜플이나 리스트의 각 요소를 여러 변수에 한 번에 할당하는 튜플 언패킹의 다양한 활용법을 보여줍니다. 기본적인 변수 할당부터, 임시 변수 없이 두 변수의 값을 교환하는 파이써닉한 방법, `for`문에서 튜플 요소를 바로 변수로 받는 법, 그리고 `*`를 사용하여 여러 요소를 하나의 리스트로 받는 확장 언패킹까지 소개합니다. |
