| 파일명 | 분류 | 설명 |
| :--- | :--- | :--- |
| `2d_list.py` | **자료구조** | 행렬이나 표 형태의 데이터를 표현하는 2차원 리스트의 초기화 방법과 순회 방식을 보여줍니다. 특히, 초기화 시 발생할 수 있는 '얕은 복사' 문제를 지적하고, 각 행이 독립적인 리스트를 갖도록 리스트 컴프리헨션을 사용하는 안전한 방법을 제시합니다. |
| `collections_counter.py` | **자료구조** | 리스트나 문자열 등 순회 가능한 객체 내 각 요소의 개수를 효율적으로 세는 `collections.Counter` 클래스를 소개합니다. `.most_common()` 메서드를 사용하여 가장 빈번하게 나타나는 항목을 찾는 등 실용적인 활용법을 보여줍니다. |
| `collections_defaultdict.py` | **자료구조** | 딕셔너리에서 존재하지 않는 키를 조회할 때 KeyError 대신 지정된 기본값을 자동으로 생성해주는 `collections.defaultdict`를 설명합니다. 키 존재 여부를 매번 확인하는 `if`문을 생략하여 코드를 간결하게 만드는 방법을 보여줍니다. |
| `collections_deque.py` | **자료구조** | 양쪽 끝에서 데이터를 O(1) 시간 복잡도로 추가/삭제할 수 있는 `collections.deque`를 소개합니다. 특히 리스트의 `pop(0)`보다 월등히 효율적이어서 큐(Queue)를 구현할 때 필수적으로 사용되는 이유를 설명합니다. |
| `counter_anagram.py` | **알고리즘** | 두 단어를 구성하는 알파벳의 종류와 개수가 정확히 일치하는 '애너그램(Anagram)' 관계를 `collections.Counter`를 이용해 판별하는 방법을 보여줍니다. 각 단어의 Counter 객체를 비교하는 것만으로 간결하게 애너그램을 확인할 수 있습니다. |
| `defaultdict_graph.py` | **자료구조** | `collections.defaultdict(list)`를 사용하여 그래프의 '인접 리스트'를 간결하게 표현하는 방법을 보여줍니다. 각 노드에 대한 리스트를 미리 초기화할 필요 없이, 간선 정보를 바로 추가할 수 있어 코드의 가독성과 편의성을 높입니다. |
| `dict_basics.py` | **자료구조** | 파이썬의 핵심 자료구조인 딕셔너리(Dictionary)의 기본적인 사용법을 다룹니다. '키(Key)'와 '값(Value)' 쌍으로 데이터를 저장하고, 키를 통해 값을 빠르게 조회, 추가, 수정, 삭제하는 방법을 설명합니다. |
| `dict_default_value.py` | **자료구조** | 딕셔너리에서 존재하지 않는 키를 조회할 때 발생하는 KeyError를 안전하게 처리하는 두 가지 방법을 비교합니다. `try-except` 구문을 사용하는 방법과, 더 간결하고 권장되는 `.get()` 메서드를 사용하여 기본값을 지정하는 방법을 보여줍니다. |
| `dict_iteration.py` | **자료구조** | 딕셔너리의 데이터를 순회하는 세 가지 주요 방법을 설명합니다. `.keys()`로 키만 순회하는 방법, `.values()`로 값만 순회하는 방법, 그리고 `.items()`로 (키, 값) 튜플 쌍을 동시에 순회하는 가장 일반적인 방법을 보여줍니다. |
| `heapq_kth_element.py` | **알고리즘** | 전체 데이터를 정렬하지 않고 K번째로 크거나 작은 원소를 효율적으로 찾는 방법을 `heapq`를 이용하여 구현합니다. 특히 K번째 큰 수를 찾을 때, 크기가 K인 최소 힙을 유지하여 O(N log K)의 시간 복잡도로 해결하는 핵심적인 아이디어를 보여줍니다. |
| `heapq_max_heap.py` | **자료구조** | 파이썬의 `heapq` 모듈이 최소 힙만 지원하지만, 값의 부호를 바꾸는 간단한 트릭을 사용하여 '최대 힙(Max Heap)'을 구현하는 방법을 보여줍니다. 데이터를 넣을 때 음수로 바꾸고, 꺼낼 때 다시 양수로 복원하여 최소 힙을 최대 힙처럼 활용합니다. |
| `heapq_min_heap.py` | **자료구조** | 파이썬에서 우선순위 큐를 구현하는 데 사용되는 `heapq` 모듈의 기본 사용법을 설명합니다. 일반 리스트를 최소 힙으로 다루게 해주는 `heapify`, `heappush`, `heappop` 함수의 사용법과 O(log N)의 시간 복잡도를 갖는 이점을 소개합니다. |
| `list_basics.py` | **자료구조** | 파이썬에서 가장 기본적이고 널리 쓰이는 자료구조인 리스트(List)의 핵심 연산을 다룹니다. 순서가 있는 변경 가능한(mutable) 시퀀스로서, `append`, `insert`, `del`, `pop`, `remove` 등 요소를 추가, 수정, 삭제하는 다양한 방법을 보여줍니다. |
| `list_comprehension.py` | **알고리즘** | `for` 루프와 `if` 조건문을 한 줄로 압축하여 간결하고 가독성 높은 코드로 리스트를 생성하는 '리스트 컴프리헨션'을 소개합니다. 단순 반복뿐만 아니라 조건에 맞는 요소만 필터링하여 새로운 리스트를 만드는 강력한 기능을 보여줍니다. |
| `list_slicing.py` | **자료구조** | 리스트의 특정 부분을 잘라내어 새로운 리스트를 만드는 슬라이싱(`[start:end:step]`) 문법을 상세히 다룹니다. 단순히 일부를 잘라내는 것 외에도, `step` 값을 이용하여 짝수/홀수 인덱스만 추출하거나, `step`을 음수로 설정하여 리스트 전체를 간단하게 뒤집는 등 실용적인 활용 예제를 보여줍니다. |
| `list_sorting.py` | **자료구조** | 리스트를 정렬하는 두 가지 주요 방법인 `.sort()` 메서드와 `sorted()` 내장 함수의 차이점을 설명합니다. 원본을 직접 수정하는 `.sort()`와 정렬된 새 리스트를 반환하는 `sorted()`의 용도를 구분하고, `key` 매개변수를 사용하여 복잡한 데이터를 원하는 기준으로 정렬하는 방법을 보여줍니다. |
| `set_basics.py` | **자료구조** | 순서가 없고 중복을 허용하지 않는 `set` 자료구조의 두 가지 핵심적인 용도를 보여줍니다. 리스트의 중복된 요소를 간단하게 제거하는 방법과, 해시 테이블 기반으로 특정 요소의 존재 여부를 O(1)의 매우 빠른 속도로 확인하는 '멤버십 테스트'의 성능적 이점을 강조합니다. |
| `set_operations.py` | **자료구조** | `set`이 제공하는 강력한 집합 연산 기능을 설명합니다. 두 집합의 모든 요소를 포함하는 합집합(`|`), 공통된 요소만 추출하는 교집합(`&`), 한 집합에만 존재하는 요소를 찾는 차집합(`-`), 그리고 두 집합 중 한쪽에만 속하는 요소를 찾는 대칭차집합(`^`)의 사용법을 보여줍니다. |
| `string_split_join.py` | **자료구조** | 문자열을 다룰 때 가장 기본적이면서 중요한 `.split()`과 `.join()` 메서드를 설명합니다. `.split()`은 문자열을 특정 구분자로 나누어 리스트로 만들고, `.join()`은 리스트의 문자열 요소들을 하나의 문자열로 합치는, 서로 반대되는 역할을 하는 두 메서드의 활용법을 보여줍니다. |
| `tuple_basics.py` | **자료구조** | 한 번 생성되면 내용을 변경할 수 없는 '불변(immutable)' 자료구조인 튜플(Tuple)의 특징과 활용법을 소개합니다. 데이터의 무결성을 보장하는 특성과, 튜플의 각 요소를 여러 변수에 한 번에 할당하는 편리한 '튜플 언패킹' 기능을 변수 값 교환(swap), 함수 반환값 처리 등의 예시와 함께 보여줍니다. |