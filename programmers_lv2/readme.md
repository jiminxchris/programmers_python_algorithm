| 파일명 | 분류 | 설명 |
| :--- | :--- | :--- |
| `collections_counter_usage.py` | **자료구조** | `collections.Counter` 객체끼리 뺄셈 연산이 가능하다는 특징을 활용하여, '참가자' 명단과 '완주자' 명단의 차이를 구해 완주하지 못한 선수를 찾는 등 문제 해결에 적용하는 방법을 보여줍니다. |
| `custom_sort_with_lambda.py`| **알고리즘** | `sorted()` 함수의 `key` 인자에 `lambda` 함수를 사용하여 복잡한 데이터 구조를 사용자 정의 기준으로 정렬하는 방법을 설명합니다. 특히, 점수를 내림차순으로, 출생년도를 오름차순으로 정렬하는 등 다중 조건 정렬을 구현하는 방법을 보여줍니다. |
| `deque_for_efficient_queue.py`| **자료구조** | 일반 리스트의 `pop(0)`가 O(N)의 비효율을 보이는 반면, `collections.deque`는 양쪽 끝에서의 데이터 추가/제거가 모두 O(1)로 매우 빠르다는 점을 강조하며, 효율적인 큐(Queue)와 덱(Deque) 구현 방법을 보여줍니다. |
| `hash_for_data_mapping.py` | **자료구조** | 키를 통해 값을 O(1)의 빠른 속도로 조회할 수 있는 딕셔너리(해시)의 장점을 활용하여, 전화번호-이름처럼 데이터를 서로 짝지어(매핑) 관리하고 조회, 추가, 업데이트하는 방법을 보여줍니다. |
| `hash_frequency_counter.py`| **자료구조** | 딕셔너리(해시 테이블)를 이용하여 리스트에 있는 각 요소가 몇 번 등장하는지 그 빈도를 효율적으로 계산하는 기본적인 방법을 설명합니다. |
| `heapq_priority_queue.py` | **자료구조** | `heapq` 라이브러리를 이용하여 우선순위가 높은(값이 작은) 데이터부터 처리하는 '우선순위 큐'를 구현하는 방법을 보여줍니다. 값의 부호를 바꾸는 트릭을 통해 최소 힙으로 최대 힙을 구현하는 방법도 함께 소개합니다. |
| `itertools_combinations_usage.py`| **알고리즘** | `itertools` 모듈의 `combinations` 함수를 사용하여, 서로 다른 n개의 원소에서 순서에 상관없이 r개를 뽑는 모든 '조합'을 간편하게 생성하는 방법을 보여줍니다. |
| `itertools_permutations_usage.py`| **알고리즘** | `itertools` 모듈의 `permutations` 함수를 사용하여, 서로 다른 n개의 원소에서 r개를 선택하여 순서대로 나열하는 모든 '순열'을 간편하게 생성하는 방법을 보여줍니다. |
| `queue_for_simulation.py`| **알고리즘** | '선입선출(FIFO)' 구조의 큐가 프린터 대기열처럼 순서대로 작업을 처리하는 시뮬레이션에 어떻게 효과적으로 사용되는지, `collections.deque`를 이용한 예제 코드를 통해 보여줍니다. |
| `stack_for_matching.py`| **알고리즘** | '후입선출(LIFO)' 구조의 스택을 이용하여 여는 괄호를 만나면 넣고, 닫는 괄호를 만나면 꺼내 짝을 확인하는 방식으로, 괄호 문자열의 유효성을 검사하는 전형적인 알고리즘을 구현합니다. |
| `string_parsing_and_conversion.py`| **알고리즘** | 문자열을 특정 규칙에 따라 분해(파싱)하고, 그 일부를 숫자로 변환하는 흔한 코딩 테스트 유형을 다룹니다. `int(string, base)` 함수를 이용해 N진수 문자열을 10진수 정수로 변환하는 방법을 보여줍니다. |
| `zip_for_parallel_iteration.py`| **자료구조** | `zip()` 함수를 사용하여 여러 리스트를 병렬로 묶어 딕셔너리를 생성하는 방법과, `zip(*matrix)` 구문을 사용하여 2차원 리스트의 행과 열을 바꾸는(전치 행렬) 유용한 테크닉을 보여줍니다. |
| `greedy_sort_and_iterate.py`| **알고리즘** | 매 순간 최적의 선택을 하는 '그리디 알고리즘'의 전형적인 문제 해결 패턴을 보여줍니다. 회의실 배정 문제를 예로 들어, 데이터를 특정 기준(종료 시간)으로 정렬한 뒤, 순서대로 처리하며 최적해를 구하는 과정을 설명합니다. |
| `bfs_queue_template.py`| **알고리즘** | `collections.deque`를 큐로 사용하여 너비 우선 탐색(BFS)을 구현하는 기본 템플릿 코드를 제공합니다. 시작 노드에서부터 가까운 노드 순으로 탐색하는 BFS의 동작 원리를 보여주며, 최단 거리 문제의 기반이 됨을 설명합니다. |
| `dfs_recursion_template.py`| **알고리즘** | 한 경로를 끝까지 탐색한 후 되돌아와 다른 경로를 탐색하는 깊이 우선 탐색(DFS)을 재귀 함수로 간결하게 구현하는 기본 템플릿 코드를 제공합니다. 그래프 탐색의 핵심적인 두 방법 중 하나인 DFS의 구조를 이해할 수 있습니다. |
| `binary_search_template.py`| **알고리즘** | **정렬된** 리스트에서 탐색 범위를 계속 절반으로 줄여나가며 O(log N)의 빠른 속도로 특정 값을 찾는 '이진 탐색' 알고리즘의 기본 템플릿 코드를 제공합니다. `low`, `high`, `mid` 포인터를 이용한 핵심 로직을 설명합니다. |
| `sieve_of_eratosthenes.py`| **알고리즘** | 특정 범위 내의 모든 소수를 매우 효율적으로 찾아내는 '에라토스테네스의 체' 알고리즘을 구현합니다. 소수의 배수들을 순차적으로 지워나가는 방식을 통해 여러 수의 소수 여부를 한 번에 판별하는 방법을 보여줍니다. |
| `two_pointers_technique.py`| **알고리즘** | **정렬된** 리스트의 양 끝에서 시작하는 두 개의 포인터(`left`, `right`)를 이용해 O(N)의 시간 복잡도로 문제(예: 두 수의 합이 target이 되는 쌍 찾기)를 해결하는 '투 포인터' 기법의 기본 구조와 원리를 설명합니다. |
| `divide_and_conquer_recursive.py`| **알고리즘** | 큰 문제를 작은 하위 문제로 나누어(분할) 해결한 뒤 결과를 합치는(정복) '분할 정복' 패러다임의 기본 구조를 재귀 함수를 이용해 설명합니다. 리스트의 합을 구하는 간단한 예제로 개념을 이해시킵니다. |
| `rotate_matrix_90_degrees.py`| **알고리즘** | 2차원 리스트(행렬)를 90도 회전시키는 두 가지 방법을 보여줍니다. 행과 열을 바꾸는 '전치' 후 각 행을 뒤집는 정석적인 방법과, `zip(*matrix)`를 활용하여 파이썬답게 더 간결하게 구현하는 방법을 함께 소개합니다. |